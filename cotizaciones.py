# -*- coding: utf-8 -*-
"""Cotizaciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I7QKCDO1xbWw1LG7PMQheKyZduK2ZLrZ
"""


"""
## Cotizaciones

En este c√≥digo podr√°s subir tus archivos de cotizaci√≥n en formato **.xlsx** para comparar los precios entre distintos proveedores y encontrar las mejores opciones.

Para usarlo:

1. Da clic en ‚ÄúEjecutar todo‚Äù en el men√∫ superior.

2. En la segunda celda, selecciona los archivos correspondientes a cada proveedor.

‚ö†Ô∏è **Importante:** Cada archivo debe incluir las siguientes columnas (con exactamente estos nombres):

- SKU

- Nombre

- Precio Unitario
"""

from google.colab import files
import pandas as pd
import os
import glob
import datetime
import pytz
from IPython.display import display, HTML

"""## Segunda Celda
Aqui agrega tus archivos
"""

# üßπ Eliminar cualquier archivo .xlsx previo en el directorio actual
for f in glob.glob("*.xlsx"):
    os.remove(f)

# üì§ Subir nuevos archivos Excel (puedes seleccionar varios)
print("üì§ Sube tus archivos Excel (uno por proveedor)...")
uploaded = files.upload()

# üìö Leer y procesar cada archivo subido
dataframes = {}
for filename in uploaded.keys():
    try:
        df = pd.read_excel(filename)
        # Normaliza encabezados y columnas clave
        df.columns = df.columns.str.strip()

        # Asegura existencia de columnas m√≠nimas (SKU y Precio Unitario). 'Nombre' puede faltar.
        min_cols = ['SKU', 'Precio Unitario']
        if not all(col in df.columns for col in min_cols):
            print(f"‚ö†Ô∏è {filename} no tiene las columnas m√≠nimas {min_cols}. Se omite.")
            continue
        if 'Nombre' not in df.columns:
            df['Nombre'] = ""  # Nombre opcional; no vamos a depender de √©l

        # üè∑Ô∏è A√±adir proveedor (ya lo haces m√°s abajo, lo dejo aqu√≠ por orden)
        df['Proveedor'] = filename.replace('.xlsx', '').replace('.xls', '')

        # Normaliza SKU como texto limpio
        df['SKU'] = df['SKU'].astype(str).str.strip()
        # Detectar SKUs inv√°lidos: letras, puntos decimales o vac√≠os
        invalid_skus = df[~df['SKU'].str.match(r'^\d+$', na=False)]

        if not invalid_skus.empty:
            print(f"‚ùå ERROR: En el archivo '{filename}' se detectaron SKUs inv√°lidos:\n")
            display(invalid_skus[['SKU']])
            raise ValueError(
                f"El archivo '{filename}' contiene SKUs no v√°lidos (con letras, decimales o vac√≠os). Corrige y vuelve a intentar."
            )

        # Si todo OK, convertir SKU a texto limpio y uniforme
        df['SKU'] = df['SKU'].astype(str)

        # Limpia Nombre (puede llegar distinto por archivo)
        df['Nombre'] = df['Nombre'].astype(str).str.strip()

        # Limpia Precio Unitario: quita s√≠mbolos, comas y espacios antes de convertir a n√∫mero
        df['Precio Unitario'] = (
            df['Precio Unitario']
              .astype(str)
              .str.replace(r'[^0-9,\.\-]', '', regex=True)  # quita $, espacios, etc.
              .str.replace(',', '', regex=False)           # quita separador de miles
        )
        df['Precio Unitario'] = pd.to_numeric(df['Precio Unitario'], errors='coerce')


        # üß© Verificar que las columnas esperadas existan
        expected_cols = ['SKU', 'Precio Unitario']  # 'Nombre' ya no es obligatorio
        if not all(col in df.columns for col in expected_cols):
            print(f"‚ö†Ô∏è {filename} no tiene las columnas esperadas. Se omite.")
            continue

        # üè∑Ô∏è A√±adir columna con el nombre del proveedor
        df['Proveedor'] = filename.replace('.xlsx', '').replace('.xls', '')

        # üßΩ Limpiar nombres de productos y tipos de datos
        df['Nombre'] = df['Nombre'].astype(str).str.strip()
        df['Precio Unitario'] = pd.to_numeric(df['Precio Unitario'], errors='coerce')

        # Guardar en diccionario
        dataframes[filename] = df
        print(f"‚úÖ Archivo cargado correctamente: {filename}")

    except Exception as e:
      print(f"‚ùå Error al leer {filename}: {e}")
      raise  # üö® vuelve a lanzar el error y detiene todo

# üëÄ Mostrar los DataFrames cargados
for nombre, df in dataframes.items():
    print(f"\nüìÑ {nombre}:")
    display(df)

# üìä Unir todos los proveedores en un solo DataFrame
merged_df = pd.concat(dataframes.values(), ignore_index=True)

# =========================
# üß† Nombre can√≥nico por SKU
# =========================
# Estrategia: usar el nombre m√°s frecuente (mode). Si no hay mode claro, usa el m√°s largo.
nombres_canon = (
    merged_df.assign(Nombre_norm=merged_df['Nombre'].astype(str).str.strip())
             .groupby('SKU')['Nombre_norm']
             .agg(lambda s: s.mode().iloc[0] if not s.mode().empty else max(s, key=len) if len(s) else "")
             .rename('Nombre_canonico')
             .reset_index()
)

# Anexar el nombre can√≥nico a la tabla combinada
merged_df = merged_df.merge(nombres_canon, on='SKU', how='left')

# üî¢ Ordenar por SKU (de menor a mayor)
merged_df = merged_df.sort_values(by='SKU', ascending=True)

# üîÑ Reindexar despu√©s del ordenamiento (opcional, solo para que los √≠ndices queden limpios)
merged_df.reset_index(drop=True, inplace=True)

print("\nüìä Vista general combinada y ordenada por SKU:")
display(merged_df.head(20))  # muestra las primeras 20 filas

# üî¢ Ignorar precios no v√°lidos
tmp = merged_df.dropna(subset=['Precio Unitario']).copy()

# üí∞ Redondear a 4 decimales solo para COMPARACI√ìN
# (mantiene los valores originales para mostrar)
tmp['Precio_cmp'] = tmp['Precio Unitario'].astype(float).round(4)

# üîç Calcular precio m√≠nimo redondeado por SKU
min_por_sku = tmp.groupby('SKU')['Precio_cmp'].transform('min')

# üîù Mejor precio por SKU (uno solo)
idx = tmp.groupby('SKU')['Precio_cmp'].idxmin()
mejores_precios_df = tmp.loc[idx].sort_values('SKU').reset_index(drop=True)

#print("‚úÖ Proveedor m√°s barato por SKU (idxmin):")
#display(mejores_precios_df)

# ‚úÖ Identificar empates: los que igualan el precio m√≠nimo redondeado
empates_df = (
    tmp[min_por_sku == tmp['Precio_cmp']]
      .sort_values(['SKU', 'Proveedor'])
      .reset_index(drop=True)
)

#print("‚ÑπÔ∏è SKUs con todos los proveedores empatados al precio m√≠nimo (comparando a 4 decimales):")
#display(empates_df)

tmp = merged_df.dropna(subset=['Precio Unitario']).copy()
min_por_sku = tmp.groupby('SKU')['Precio Unitario'].transform('min')
empates_df = (
    tmp[min_por_sku == tmp['Precio Unitario']]
      .sort_values(['SKU', 'Proveedor'])
      .reset_index(drop=True)
)

print("‚ÑπÔ∏è SKUs con todos los proveedores empatados al precio m√≠nimo:")
display(empates_df[['SKU', 'Nombre', 'Precio Unitario']])

# üïí Crear timestamp actual (formato legible: YYYYMMDD_HHMMSS)
cst = pytz.timezone("America/Mexico_City")
timestamp = datetime.datetime.now(cst).strftime("%Y%m%d_%H%M%S")

# üìÅ Crear carpeta de resultados
os.makedirs("resultados", exist_ok=True)

# üìÑ Nombre del archivo con timestamp y palabra 'cotizacion'
filename = f"resultados/cotizacion_{timestamp}.xlsx"

# üíæ Guardar el DataFrame de empates en un archivo Excel
empates_df.to_excel(filename, index=False)

print(f"‚úÖ Archivo generado y guardado en: {filename}")

# üì§ Descargar el archivo (opcional, si est√°s en Google Colab)
files.download(filename)

# =========================
# üìù Resumen profesional a partir de empates_df
# =========================

# Copia y columnas auxiliares para orden
_emp = empates_df.copy()
_emp['SKU_str'] = _emp['SKU'].astype(str)
_emp['SKU_num'] = pd.to_numeric(_emp['SKU'], errors='coerce')

# Separar ganadores √∫nicos (SKU que aparecen 1 sola vez en empates_df)
counts = _emp.groupby('SKU_str')['SKU_str'].transform('size')
ganadores_unicos = _emp[counts == 1].copy()
empates_reales  = _emp[counts > 1].copy()

# Ordenar para salida limpia
ganadores_unicos = ganadores_unicos.sort_values(
    by=['Proveedor', 'SKU_num', 'SKU_str'], ascending=[True, True, True]
).reset_index(drop=True)

empates_reales = empates_reales.sort_values(
    by=['SKU_num', 'Proveedor', 'Precio Unitario'], ascending=[True, True, True]
).reset_index(drop=True)

# Construir mensaje
lineas = []
lineas.append("Tu cotizaci√≥n ha finalizado. El resumen es:\n")

if ganadores_unicos.empty:
    lineas.append("No hay ganadores √∫nicos por SKU.\n")
else:
    for prov, g in ganadores_unicos.groupby('Proveedor', sort=True):
        lineas.append(f"{prov} ‚Äî tendr√°s que pedirle los siguientes productos:")
        for _, r in g.iterrows():
            lineas.append(f"  - SKU {r['SKU']} ‚Äî {r['Nombre_canonico']} ‚Äî ${r['Precio Unitario']:.4f}")
        lineas.append("")  # l√≠nea en blanco entre proveedores

# Empates al final
lineas.append("A continuaci√≥n se muestran los empates para que decidas t√∫ a qui√©n pedirlo:")

if empates_reales.empty:
    lineas.append("No hay empates.")
else:
    for sku, g in empates_reales.groupby('SKU_str', sort=False):
        # usa la primera fila para mostrar el nombre
        nombre = g.iloc[0]['Nombre_canonico']
        lineas.append(f"  ‚Ä¢ SKU {sku} ‚Äî {nombre}:")
        for _, r in g.iterrows():
            lineas.append(f"      - {r['Proveedor']} ‚Äî ${r['Precio Unitario']:.4f}")
        lineas.append("")

mensaje_resumen = "\n".join(lineas)
print(mensaje_resumen)

def _fmt_money4(x):
    try:
        return f"${float(x):,.4f}"
    except:
        return x

# Reinicia el HTML
html_message = """
<div class='box'>
  <h3>üíº Tu cotizaci√≥n ha finalizado</h3>
  <p style='color:#7F8C8D; margin-top:-6px'>
    Resumen profesional a partir de precios m√≠nimos y empates por SKU.
  </p>

  <h4>üèÜ Ganadores por proveedor</h4>
"""

# ===== Ganadores por proveedor: tabla por proveedor =====
if not ganadores_unicos.empty:
    for prov, g in ganadores_unicos.groupby('Proveedor', sort=True):
        g2 = (
            g[['SKU','Nombre_canonico','Precio Unitario']]
            .rename(columns={'Nombre_canonico':'Nombre', 'Precio Unitario':'Precio'})
            .sort_values(['SKU'])
            .copy()
        )
        g2['Precio'] = g2['Precio'].map(_fmt_money4)
        html_message += f"<h5>üè™ {prov}</h5>"
        html_message += g2.to_html(index=False, escape=False, classes='tbl')
        html_message += "<br>"
else:
    html_message += "<p style='color:#7F8C8D;'>No hay ganadores √∫nicos por SKU.</p>"

# ===== Empates detectados: una secci√≥n por SKU =====
html_message += "<hr><h4>‚öñÔ∏è Empates detectados</h4>"

if not empates_reales.empty:
    for sku, g in empates_reales.groupby('SKU_str', sort=False):
        nombre = g.iloc[0]['Nombre_canonico']
        html_message += f"<h5>SKU {sku} ‚Äî {nombre}</h5>"
        e2 = (
            g[['Proveedor','Precio Unitario']]
            .rename(columns={'Precio Unitario':'Precio'})
            .sort_values(['Proveedor'])
            .copy()
        )
        e2['Precio'] = e2['Precio'].map(_fmt_money4)
        html_message += e2.to_html(index=False, escape=False, classes='tbl')
        html_message += "<br>"
else:
    html_message += "<p style='color:#7F8C8D;'>No hay empates.</p>"

# ===== Estilos (mismo formato que vienes usando) =====
html_message += """
</div>

<style>
  /* üîß Contenedor general */
  .box {
    font-family: Roboto, Arial, sans-serif;
    font-size: 15px;
    background: #F9FBFD;
    border: 1px solid #D6EAF8;
    border-radius: 10px;
    padding: 16px;
    text-align: left;
  }

  .box h3 {
    color: #2E86C1;
    margin: 0 0 12px 0;
    text-align: left;
  }

  .box h4 {
    color: #34495E;
    margin: 14px 0 8px 0;
    text-align: left;
  }

  .box h5 {
    color: #1A5276;
    margin: 10px 0 6px 0;
    text-align: left;
  }

  /* üîß Tabla base */
  .tbl {
    width: auto;
    border-collapse: collapse;
    background: #fff;
    border: 1px solid #E5EAF2;
    border-radius: 10px;
    margin-left: 0;
  }

  .tbl th, .tbl td {
    padding: 8px 10px;
    border-bottom: 1px solid #EEF2F7;
    vertical-align: middle;
    text-align: left;
  }

  .tbl thead th {
    background: #F3F7FB;
    color: #2C3E50;
    font-weight: 600;
    font-size: 14px;
  }

  .tbl tbody tr:hover {
    background: #FAFCFF;
  }
</style>
"""

display(HTML(html_message))

"""## Elimina dentro de la carpeta "resultados" archivos que no coinciden con el d√≠a de hoy"""

today_str = datetime.datetime.now(cst).strftime("%Y%m%d")

# üìÅ Ruta de carpeta de resultados
results_dir = "resultados"

# üßπ Crear carpeta si no existe
os.makedirs(results_dir, exist_ok=True)

# üßΩ Eliminar archivos cuyo nombre NO coincide con la fecha actual
for fname in os.listdir(results_dir):
    if not fname.endswith(".xlsx"):
        continue
    # Extraer la fecha del nombre del archivo (ej. cotizacion_20251025_153022.xlsx)
    try:
        date_part = fname.split("_")[1]
    except IndexError:
        continue
    # Si no coincide con el d√≠a actual, eliminar
    if not date_part.startswith(today_str):
        full_path = os.path.join(results_dir, fname)
        try:
            os.remove(full_path)
            print(f"üóëÔ∏è Eliminado archivo antiguo: {fname}")
        except Exception as e:
            print(f"‚ö†Ô∏è No se pudo eliminar {fname}: {e}")
